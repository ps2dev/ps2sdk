/*	iLink_PHT.c
 *	Purpose:	Contains the functions related to IEEE1394 read/write requests that are to be generated by PHT 00, and functions related to initializing both PHTs and DMAC #3.
 *			Only block reads and writes are supported by functions in this files.
 *
 *	Last Updated:	2012/02/22
 *	Programmer:	SP193
 */

#include <dmacman.h>
#include <stdio.h>
#include <sysmem.h>
#include <thbase.h>
#include <thevent.h>

#include "iLinkman.h"
#include "iLink_internal.h"

extern unsigned short int LocalNodeID;
extern int IntrEventFlag;

extern int GenerationNumber;

extern struct ILINKMemMap *ILINKRegisterBase;
extern unsigned int *TargetBuffer;
extern unsigned int LocalCachedIntr0Register;

struct DMAChannelRegBlock *iLinkDMACRegs = (struct DMAChannelRegBlock *)ILINK_DMAC_REGISTER_BASE;
struct DMARRegBlock *iLinkDMARRegs = (struct DMARRegBlock *)ILINK_DMAC_DMAR_CTRL_BASE;

static int iLinkPHTSendData(struct TransactionContextData *trContext, unsigned char tCode, unsigned short int offset_high, unsigned int offset_low, unsigned int *payload, unsigned int nBytes, char ByteSwap);

void iLinkInitPHT(void)
{
	/* Stop all DMA-related activities */
	iLinkDMACRegs[0].chcr = iLinkDMACRegs[2].chcr = 0;

	ILINKRegisterBase->PHT_ctrl_ST_R0 = PHT_CTRL_ST_PHTRst; /* Reset PHT 00 */
	ILINKRegisterBase->PHT_ctrl_ST_R1 = PHT_CTRL_ST_PHTRst; /* Reset PHT 01 */

	while ((ILINKRegisterBase->PHT_ctrl_ST_R0 & PHT_CTRL_ST_PHTRst) || (ILINKRegisterBase->PHT_ctrl_ST_R1 & PHT_CTRL_ST_PHTRst)) {
	};

	ILINKRegisterBase->dmar = 0x00000020;                                      /* DMA space is within the 2MB of IOP memory. */
	ILINKRegisterBase->PHT_ctrl_ST_R1 = PHT_CTRL_ST_EnDMAS | PHT_CTRL_ST_IHdr; /* EnDMAS | IHdr */
	ILINKRegisterBase->PHT_ctrl_ST_R0 = 0;

	ILINKRegisterBase->STRxNIDSel0_R1 = ILINKRegisterBase->STRxNIDSel1_R1 = 0xFFFFFFFF; /* Accept DMA transfers from all nodes. */
	ILINKRegisterBase->STRxNIDSel0_R0 = ILINKRegisterBase->STRxNIDSel1_R0 = 0;          /* Reject DMA transfers from all nodes. */

	iLinkDMACRegs[0].slice = iLinkDMACRegs[2].slice = 0x400;
	iLinkDMACRegs[2].chcr = DMAC_CHCR_AR | DMAC_CHCR_CO;

	iLinkDMACRegs[0].DmarReadStart = iLinkDMACRegs[2].DmarReadStart = iLinkDMARRegs->DmarWriteStart = 0x00000800;
	iLinkDMACRegs[0].DmarReadEnd = iLinkDMACRegs[2].DmarReadEnd = iLinkDMARRegs->DmarWriteEnd = 0x00200000;

	ILINKRegisterBase->dmaTransTRSH0 = 0x03FF0000;
	ILINKRegisterBase->dmaTransTRSH1 = 0x000F03FF;
	ILINKRegisterBase->dmaCtrlSR0 = ILINKRegisterBase->dmaCtrlSR1 = iLinkDMA_CTRL_SR_LFirst | iLinkDMA_CTRL_SR_DWidth(2) | iLinkDMA_CTRL_SR_DEn | iLinkDMA_CTRL_SR_RActl;

	ILINKRegisterBase->PHT_split_TO_R1 = ILINKRegisterBase->PHT_split_TO_R0 = 0x00000800; /* STO: 0x800 */
}

static int iLinkPHTSendData(struct TransactionContextData *trContext, unsigned char tCode, unsigned short int offset_high, unsigned int offset_low, unsigned int *payload, unsigned int nBytes, char ByteSwap)
{
	unsigned char tLabel;
	unsigned int PHT_ctrl_ST_R0_flags;

	if (trContext->GenerationNumber != GenerationNumber)
		return (-1021);

	ClearEventFlag(IntrEventFlag, ~(iLinkEventDMATransEnd | iLinkEventError));

	ByteSwap = 0;

	PHT_ctrl_ST_R0_flags = (tCode == IEEE1394_TCODE_WRITEB) ? PHT_CTRL_ST_EPCNT | PHT_CTRL_ST_EWREQ : PHT_CTRL_ST_EPCNT | PHT_CTRL_ST_ERREQ; /* EWReq and EPCnt, OR ERReq and EPCnt. */
	tLabel = 0x3F;                                                                                                                           /* PHT 00 */

	ILINKRegisterBase->PHT_ReqResHdr0_R0 = (((unsigned int)trContext->NodeID) << 16) | offset_high;
	ILINKRegisterBase->PHT_ReqResHdr1_R0 = offset_low;
	ILINKRegisterBase->PHT_ReqResHdr2_R0 = (((unsigned int)tLabel) << 19) | (((unsigned int)trContext->speed) << 16) | nBytes;

	ILINKRegisterBase->DTransCTRL0 = 1; /* Only 1 packet. */
	ILINKRegisterBase->PHT_ctrl_ST_R0 |= PHT_ctrl_ST_R0_flags;

	iLinkDMACRegs[0].madr = (unsigned int)payload;
	iLinkDMACRegs[0].dlen = nBytes;
	iLinkDMACRegs[0].chcr = DMAC_CHCR_TR | DMAC_CHCR_CO;

	DEBUG_PRINTF("Waiting for interrupt...\n");
	WaitEventFlag(IntrEventFlag, iLinkEventDMATransEnd | iLinkEventError, WEF_OR, NULL);

	ILINKRegisterBase->PHT_ctrl_ST_R0 &= (~PHT_ctrl_ST_R0_flags);

	DEBUG_PRINTF("Processing results...\n");

	if (LocalCachedIntr0Register & iLink_INTR0_InvAck)
		return (-1023);
	if (LocalCachedIntr0Register & iLink_INTR0_STO)
		return (-1024);
	if (LocalCachedIntr0Register & iLink_INTR0_AckMiss)
		return (-1025);
	if (LocalCachedIntr0Register & iLink_INTR0_RetEx)
		return (-1026);

	return nBytes;
}

/* !!! NOTE !!! This function only supports issuing BLOCK read requests! Quadlet read requests should be issued with the equilvalent function that uses the UBUF. */
int iLinkReadPHTReq(struct TransactionContextData *trContext, unsigned short int offset_high, unsigned int offset_low, void *buffer, unsigned int nBytes)
{
	DEBUG_PRINTF("iLinkReadPHTReq() 0x%08x 0x%08x; nbytes: 0x%08x. Node: 0x%04x.\n", offset_high, offset_low, nBytes, trContext->NodeID);

	TargetBuffer = buffer;

	return (iLinkPHTSendData(trContext, IEEE1394_TCODE_READB, offset_high, offset_low, NULL, nBytes, 0));
}

/* !!! NOTE !!! This function only supports issuing BLOCK write requests! Quadlet write requests should be issued with the equilvalent function that uses the UBUF. */
int iLinkWritePHTReq(struct TransactionContextData *trContext, unsigned short int offset_high, unsigned int offset_low, void *buffer, unsigned int nBytes)
{
	DEBUG_PRINTF("iLinkWritePHTReq() 0x%08x 0x%08x; nbytes: 0x%08x. Node: 0x%04x.\n", offset_high, offset_low, nBytes, trContext->NodeID);

	return (iLinkPHTSendData(trContext, IEEE1394_TCODE_WRITEB, offset_high, offset_low, buffer, nBytes, 1));
}
