/*	iLink_PHT.c
 *	Purpose:	Contains the functions related to IEEE1394 read/write requests that are to be generated by PHT 00, and functions related to initializing both PHTs and DMAC #3.
 *			Only block reads and writes are supported by functions in this files.
 *
 *	Last Updated:	2012/02/22
 *	Programmer:	SP193
 */

#include <dmacman.h>
#include <stdio.h>
#include <sysmem.h>
#include <thbase.h>
#include <thevent.h>

#include "iLinkman.h"
#include "iLink_internal.h"

extern unsigned short int LocalNodeID;
extern int IntrEventFlag;

extern int GenerationNumber;

extern struct ILINKMemMap *ILINKRegisterBase;
extern unsigned int *TargetBuffer;
extern unsigned int LocalCachedIntr0Register;

struct DMAChannelRegBlock *iLinkDMACRegs=(struct DMAChannelRegBlock *)ILINK_DMAC_REGISTER_BASE;
struct DMARRegBlock *iLinkDMARRegs=(struct DMARRegBlock *)ILINK_DMAC_DMAR_CTRL_BASE;

static int iLinkPHTSendData(struct TransactionContextData *trContext, unsigned char tCode, unsigned short int offset_high, unsigned int offset_low, unsigned int *payload, unsigned int nBytes, char ByteSwap);

void iLinkInitPHT(void){
	/* Stop all DMA-related activities */
	iLinkDMACRegs[0].chcr=iLinkDMACRegs[2].chcr=0;

	ILINKRegisterBase->PHT_ctrl_ST_R0=PHT_CTRL_ST_PHTRst;	/* Reset PHT 00 */
	ILINKRegisterBase->PHT_ctrl_ST_R1=PHT_CTRL_ST_PHTRst;	/* Reset PHT 01 */

	while((ILINKRegisterBase->PHT_ctrl_ST_R0&PHT_CTRL_ST_PHTRst) || (ILINKRegisterBase->PHT_ctrl_ST_R1&PHT_CTRL_ST_PHTRst)){};

	ILINKRegisterBase->dmar=0x00000020;		/* DMA space is within the 2MB of IOP memory. */
	ILINKRegisterBase->PHT_ctrl_ST_R1=PHT_CTRL_ST_EnDMAS|PHT_CTRL_ST_IHdr; /* EnDMAS | IHdr */
	ILINKRegisterBase->PHT_ctrl_ST_R0=0;

	ILINKRegisterBase->STRxNIDSel0_R1=ILINKRegisterBase->STRxNIDSel1_R1=0xFFFFFFFF;	/* Accept DMA transfers from all nodes. */
	ILINKRegisterBase->STRxNIDSel0_R0=ILINKRegisterBase->STRxNIDSel1_R0=0;		/* Reject DMA transfers from all nodes. */

	iLinkDMACRegs[0].slice=iLinkDMACRegs[2].slice=0x400;
	iLinkDMACRegs[2].chcr=DMAC_CHCR_AR|DMAC_CHCR_CO;

	iLinkDMACRegs[0].DmarReadStart=iLinkDMACRegs[2].DmarReadStart=iLinkDMARRegs->DmarWriteStart=0x00000800;
	iLinkDMACRegs[0].DmarReadEnd=iLinkDMACRegs[2].DmarReadEnd=iLinkDMARRegs->DmarWriteEnd=0x00200000;

	ILINKRegisterBase->dmaTransTRSH0=0x03FF0000;
	ILINKRegisterBase->dmaTransTRSH1=0x000F03FF;
	ILINKRegisterBase->dmaCtrlSR0=ILINKRegisterBase->dmaCtrlSR1=iLinkDMA_CTRL_SR_LFirst|iLinkDMA_CTRL_SR_DWidth(2)|iLinkDMA_CTRL_SR_DEn|iLinkDMA_CTRL_SR_RActl;

	ILINKRegisterBase->PHT_split_TO_R1=ILINKRegisterBase->PHT_split_TO_R0=0x00000800;	/* STO: 0x800 */
}

static int iLinkPHTSendData(struct TransactionContextData *trContext, unsigned char tCode, unsigned short int offset_high, unsigned int offset_low, unsigned int *payload, unsigned int nBytes, char ByteSwap){
	unsigned char tLabel;
	unsigned int PHT_ctrl_ST_R0_flags;

	if(trContext->GenerationNumber!=GenerationNumber) return(-1021);

	ClearEventFlag(IntrEventFlag, ~(iLinkEventDMATransEnd|iLinkEventError));

	ByteSwap=0;

	PHT_ctrl_ST_R0_flags=(tCode==IEEE1394_TCODE_WRITEB)?PHT_CTRL_ST_EPCNT|PHT_CTRL_ST_EWREQ:PHT_CTRL_ST_EPCNT|PHT_CTRL_ST_ERREQ;	/* EWReq and EPCnt, OR ERReq and EPCnt. */
	tLabel=0x3F;	/* PHT 00 */

	ILINKRegisterBase->PHT_ReqResHdr0_R0=(((unsigned int)trContext->NodeID)<<16) | offset_high;
	ILINKRegisterBase->PHT_ReqResHdr1_R0=offset_low;
	ILINKRegisterBase->PHT_ReqResHdr2_R0=(((unsigned int)tLabel)<<19) | (((unsigned int)trContext->speed)<<16) | nBytes;

	ILINKRegisterBase->DTransCTRL0=1;	/* Only 1 packet. */
	ILINKRegisterBase->PHT_ctrl_ST_R0|=PHT_ctrl_ST_R0_flags;

	iLinkDMACRegs[0].madr=(unsigned int)payload;
	iLinkDMACRegs[0].dlen=nBytes;
	iLinkDMACRegs[0].chcr=DMAC_CHCR_TR|DMAC_CHCR_CO;

	DEBUG_PRINTF("Waiting for interrupt...\n");
	WaitEventFlag(IntrEventFlag, iLinkEventDMATransEnd|iLinkEventError, WEF_OR, NULL);

	ILINKRegisterBase->PHT_ctrl_ST_R0&=(~PHT_ctrl_ST_R0_flags);

	DEBUG_PRINTF("Processing results...\n");

	if(LocalCachedIntr0Register&iLink_INTR0_InvAck) return(-1023);
	if(LocalCachedIntr0Register&iLink_INTR0_STO) return(-1024);
	if(LocalCachedIntr0Register&iLink_INTR0_AckMiss) return(-1025);
	if(LocalCachedIntr0Register&iLink_INTR0_RetEx) return(-1026);

	return nBytes;
}

/* !!! NOTE !!! This function only supports issuing BLOCK read requests! Quadlet read requests should be issued with the equilvalent function that uses the UBUF. */
int iLinkReadPHTReq(struct TransactionContextData *trContext, unsigned short int offset_high, unsigned int offset_low, void *buffer, unsigned int nBytes){
	DEBUG_PRINTF("iLinkReadPHTReq() 0x%08x 0x%08x; nbytes: 0x%08x. Node: 0x%04x.\n", offset_high, offset_low, nBytes, trContext->NodeID);

	TargetBuffer=buffer;

	return(iLinkPHTSendData(trContext, IEEE1394_TCODE_READB, offset_high, offset_low, NULL, nBytes, 0));
}

/* !!! NOTE !!! This function only supports issuing BLOCK write requests! Quadlet write requests should be issued with the equilvalent function that uses the UBUF. */
int iLinkWritePHTReq(struct TransactionContextData *trContext, unsigned short int offset_high, unsigned int offset_low, void *buffer, unsigned int nBytes){
	DEBUG_PRINTF("iLinkWritePHTReq() 0x%08x 0x%08x; nbytes: 0x%08x. Node: 0x%04x.\n", offset_high, offset_low, nBytes, trContext->NodeID);

	return(iLinkPHTSendData(trContext, IEEE1394_TCODE_WRITEB, offset_high, offset_low, buffer, nBytes, 1));
}
